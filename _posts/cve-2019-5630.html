---
creation_epoch: 1578426339
lastmod_epoch: 1578426339
categories: ['Security']
title: CVE-2019-5630
---


<h1>CVE-2019-5630</h1>
Cross-Site Request Forgery (CSRF) vulnerability was found in Rapid7 Nexpose InsightVM Security Console 

<p>
Notes from a vulnerability I found and reported to Rapid7 with their product's API behavior.  Using Flash (still available in Google Chrome until Dec. 2020) one could use a wateringhole attack to perform a CSRF request.  Enables an attacker to gain access to the Rapid7 console.
</p>

<p>
The vendor worked with me and released a fix.  <a href="https://help.rapid7.com/nexpose/en-us/release-notes/archive/2019/06/">Version 6.5.69</a>
</p>

<p>
I was reading security news and found a new published technique for CSRF using Flash and the Content-Type header.<br /> <a href="https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b">
Exploiting CSRF on JSON endpoints with Flash and redirects
</a><br />
Jan. 30, 2018
</p>

<p>
It is possible using the latest Google Chrome (Version 74.0.3729.131 (Official Build) (64-bit)) and the built-in Flash player in Chrome to execute CSRF against a logged in user of insightVM.
</p>

<p>
The attached PoC targets a victim with global admin role and ***creates another global admin secretly*** in the background. This is possible because an HTTP 307 redirect transmitted via Flash forwards on the Content-Type of application/json. IE11, Firefox do not have this behavior.
</p>

<p>
The REST API makes the assumption that the Content-Type: application/json will be present or it fails the request. This is no longer sufficient to stop CSRF. Additionaly, the 'enctype' attribute of the FORM HTML element almost had a W3 standard added to permit setting content-type to application/json (see https://www.w3.org/TR/html-json-forms/ )
</p>

<p>
Any REST API can be called, but the PoC shows creating a global admin user.
</p>


<h3>Requirements:</h3>
<ol>
<li>Victim must use Chrome
	<ul><li>(other browsers on Mac or mobile could be vulnerable)</li></ul>
	<ul><li>(only Window was tested, IE11 & Firefox were not vuln)</li></ul>
</li>
<li>Victim visits some site by attacker</li>
<li>Victim Clicks to run the flash content
	<ul><li>Scenario: Offer to watch some videos of cats being cute</li></ul>
</li>
</ol>

<p>
Flash content could show actual video or anything as the attack is then run silently in the background. Flash code could also wait for victim to login to their console in another tab (watering hole attack).
</p>


<h3>Steps to Reproduce:</h3>
<ol>
<li>Setup an attacker server with Python version 2 and run hack-py-redirect-server.py
	<ul><li>Update the Location URL value to your console</li></ul>
</li>
<li>Copy csrw.swf compiled code to same directory as python script
	<ul><li>I had to set JAVA_HOME=c:\jdk1.8.0_212 as placing the 32-bit JRE in the PATH was not enough for mxmlc.exe to work</li>
	<li>I used flex_sdk_4.6</li>
	</ul>
</li>
<li>Victim logs into their console as a global admin</li>
<li>Victim opens another tab to go to their favorite cat site</li>
<li>Victim foolishly Click to run on the flash and their "video" starts</li>
<li>Attacker now has an account as global admin to their console.</li>
</ol>

<p>
<a href="https://github.com/rbeede/CVE-2019-5630">Github PoC files</a>
</p>


<h3>Remediation:</h3>
<p>
Vendor has released a patch (fixed June 26, 2019; disclosed May 7, 2019).
</p>

<p>
In general practice a REST API might want to ignore cookies used for logged in sessions from web UIs.  An alternative if cookies are needed would be to use alternative names for the cookies of API calls.
</p>

<p>
Another check could be the Referer or Origin headers, but it is dependent on expected clients.
</p>

<p>
Note that Flash was the entry-way this time, but in the future other factors could permit the Content-Type: application/json submission as well. It should be assumed that checking content-type alone is not sufficient to prevent CSRF.
</p>

<p>
The flaw roots from the assumption that web browsers cannot set certain HTTP headers or values, but that should not be considered a sufficient control for CSRF prevention.
</p>
